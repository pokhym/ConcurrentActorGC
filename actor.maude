mod ACTOR is protecting NAT . protecting LIST{Nat} .
	protecting QID-LIST .

	--- sorts List QidList .
	sorts Reference ReferenceList .
	sorts Actor ActorList .
	sorts Configuration NatConfiguration .
	
	--- We want to be able to have a list of references
	subsort Reference < Qid .
	subsort ReferenceList < QidList .
	subsort Actor < ActorList < QidList .


	--- identities
	op Null : -> Nat [ctor] .
	op mtRef : -> Reference [ctor] .
	--- op mtConf : -> Configuration .

	---
	op _::_->_ : Nat Nat Nat -> Reference [ctor] .
	
	--- i = id, sn = seqnum, r = refs, dr = deactivated_refs, o = owners, ro = released_owners, m = memory, oa = onack
	op < i: _ | sn: _ | r: _ | dr: _ | o: _ | ro: _ | m: _ | oa: _ > : Nat Nat ReferenceList ReferenceList ReferenceList 
															ReferenceList ReferenceList ReferenceList ->  Actor [ctor] .
	op _$_ : Actor Actor -> ActorList [ctor] .

	--- Configuration is a set of actors together
	--- TODO: Does this need to have 2 actorlists? or is it because
	--- We can concatenate actorlists via QID-LIST do we still need to wory about this?
	op { _ } : ActorList -> Configuration [ctor] .
	
	--- NatConfiguration also gives us global variables for actor ID and reference ID
	--- this allows us to have a unique name for every actor and reference
	--- NextActorID NextReferenceID Configuration -> NatConfiguration
	op ___ : Nat Nat Configuration -> NatConfiguration [ctor] .

	--- Methods for NatConfiguration
	op getNextActorId(_) : NatConfiguration -> Nat .
	op getNextRefId(_) : NatConfiguration -> Nat .

	--- Methods Declarations an Actor has
	--- Actor Constructor: ActorID1 to be created, ActorID2 of first reference, next unique refID
	--- NOTE: refID :: ActorID1 -> ActorID2
	op newActor(_,_,_) : Nat Nat Nat -> Actor [ctor] .
	--- Spawn: Allows an actor A to spawn a child
	op spawn(_) : Actor -> Actor [ctor] .
	--- createRef: Creates a reference C -> B if given A -> B and A -> C
	op createRef(_,_) : Reference Reference -> Actor .
	--- receive: Allows an actor A to recieve a new reference
	op receive(_) : Reference -> Actor .
	--- release: Allows an actor to release an input reference
	op release(_) : Reference -> Actor .
	--- updateInfo: Called by actor A release an actor B to update local variables and send a release
	--- request to actor B
	op updateInfo(_) : Nat -> Actor .
	--- releaseRecv: Called by an actor B which received a recieve request from A
	--- this will release references in B and send an ack to A
	op releaseRecv(_,_,_,_) : Nat Nat ReferenceList ReferenceList -> Actor .
	--- ackRelease: This is sent by actor B to A as an ack
	op ackRelease(_) : Nat -> Actor .

	--- Top Level G functions
	--- TODO: How do we address getting more than one actor?
	op newActorList(_) : Nat{List} -> ActorList [ctor] .

	--- Variable declarations
	vars Conf : Configuration .
	vars A B X ActID RefID : Nat .
	
	--- implementations for NatConfiguration
	eq getNextActorId(N M Conf) = N + 1 .
	eq getNextRefId(N,M ^ Conf) = M + 1 .

	--- implementations for Actor
	eq newActor(A, B, X) = < i: A | sn: 0 | r: X :: A -> B | dr: mtRef | o: mtRef | ro: mtRef | m: mtRef | oa: mtRef > .

	---
	rl [newActor] :  ActID || { Conf } => N + 1 || { newActor(N + 1, M) Conf } .

endm

--- test configuration 
--- red { A:ActorList B:ActorList } .
--- red { < i: 0 | sn: 0 | r: 0 :: 0 -> 0 | dr: 0 :: 0 -> 0 | o: 0 :: 0 -> 0 | ro: 0 :: 0 -> 0 | m: 0 :: 0 -> 0 | oa: 0 :: 0 -> 0 > } .
--- red 0 0 || { A:ActorList } .

--- test NatConfiguration
--- red 15,5 |^| { A:ActorList B:ActorList } .

--- test get next id
red { A:ActorList B:ActorList }.
red getNextActorId(15 5 { A:ActorList }) .
--- red getNextRefId(15,5 ^ { A:ActorList B:ActorList }) .


--- test reference list
--- red (0 :: 0 -> 0) (1 :: 1 -> 0) .

--- test Actor/ActorList
--- red < i: 0 | sn: 0 | r: 0 :: 0 -> 0 | dr: 0 :: 0 -> 0 | o: 0 :: 0 -> 0 | ro: 0 :: 0 -> 0 | m: 0 :: 0 -> 0 | oa: 0 :: 0 -> 0 > $ < i: 0 | sn: 0 | r: 0 :: 0 -> 0 | dr: 0 :: 0 -> 0 | o: 0 :: 0 -> 0 | ro: 0 :: 0 -> 0 | m: 0 :: 0 -> 0 | oa: 0 :: 0 -> 0 > .