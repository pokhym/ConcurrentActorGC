***(
	TODO:
	NE-LIST vs LIST (CHECK MAUDE BOOK), NE should be ctor, list is no ctor

	still need to do _,_ uniqueness?

	remove onack map? would it be easier to prove?
)

set include BOOL off .

--- load util.maude
load reference.maude

view TrivAsReferenceList from TRIV to REFERENCE is
	sort Elt to ReferenceList .
endv

view TrivAsiNat from TRIV to INAT is
	sort Elt to iNat .
endv

fmod ACTOR is 
	protecting PRED .
	protecting INAT .
	protecting REFERENCE .
	protecting MAP{TrivAsiNat, TrivAsReferenceList} .
	
	--- ########## SORTS ##########
	sorts Actor ActorList .
	
	--- ########## SUBSORTS ##########
	subsort Actor < ActorList .

	--- ########## OPS ##########
	--- identities
	op mtActor : -> Actor [ctor] .
	op mtActorList : -> ActorList [ctor] .

	--- i = id, sn = seqnum, r = refs, dr = deactivated_refs, o = owners, ro = released_owners, 
	--- m = memory, tr = target_releasing, owr = owner_releasing, oa = onack
	op < i: _ | sn: _ | r: _ | dr: _ | o: _ | ro: _ | m: _ | tr: _ | owr: _ | oa: _ > : 
		iNat iNat ReferenceList ReferenceList ReferenceList ReferenceList ReferenceList 
			ReferenceList ReferenceList Map{TrivAsiNat, TrivAsReferenceList} ->  Actor [ctor] .
	--- TODO: Should this check for uniqueness (set) for i?
	op _,_ : ActorList ActorList -> ActorList [ctor assoc id: mtActorList] .

	--- Methods Declarations an Actor has
	--- Actor Constructor: ActorID1 to be created, ActorID2 of first reference, next unique refID
	--- NOTE: refID :: ActorID1 -> ActorID2
	op newActor(_,_) : iNat ReferenceList -> Actor [ctor] .
	--- Spawn: Allows an actor A to spawn a child, this is just a renaming of newActor
	--- to spawn multiple actors refer to the rules in G
	op spawn(_,_) : iNat ReferenceList -> ActorList .
	--- createRef: Creates a reference C -> B if given A -> B and A -> C
	op createRef(_,_,_) : iNat Reference Reference -> Reference .
	--- receive: Allows an actor A to recieve a new reference
	op receive(_,_) : Actor Reference -> Actor .
	--- release: Allows an actor to release an input reference, this only edits deactivated_refs
	--- updateInfo will be called alongside release in the relese rule which will also do error checking to see if
	--- the input reference is actually in the Actor.refs
	op release(_,_) : Actor Reference -> Actor .
	--- updateInfo: Called by actor A release an actor B to update local variables
	--- the actual release message will be created and sent via the rule into the soup
	op updateInfo(_,_) : Actor iNat -> Actor .
	--- releaseRecv: Called by an actor B which received a recieve request from A
	--- this will release references in B and send an ack to A
	op releaseRecv(_,_,_,_) : iNat iNat ReferenceList ReferenceList -> Actor .
--- 	--- ackRelease: This is sent by actor B to A as an ack
	op ackRelease(_) : iNat -> Actor .

	--- ########## HELPER OPS ##########
	--- releasingEquiv(B, x : A -> B) = tt, releasingEquiv(B, x : A -> C) = ff
	op releasingEquiv(_,_) : iNat Reference -> Pred .
	--- releasingRefList(B, (x : A -> B), (y : C -> B), (z : D -> E)) returns x, y
	--- b: B, deactivatedRefs
	--- op releasingRefList(_,_) : iNat ReferenceList -> ReferenceList .
	op releasingRefList(_,_) : iNat ReferenceList -> ReferenceList .
	--- createdRefList(B, (x : A -> B), (y : C -> B), (z : D -> B), (y : C -> B)) returns z : D -> B
	--- b : B, Memory, TargetReleasing
	op createdRefList(_,_,_) : iNat ReferenceList ReferenceList -> ReferenceList .
	--- sentRefList(B, (x : A -> B), (y : E -> C), (z : B -> D), (y : C -> B)) returns z : B -> D
	op sentRefList(_,_,_) : iNat ReferenceList ReferenceList -> ReferenceList .
	--- genOnAckMap()
	op genOnAckMap(_,_,_) : ReferenceList ReferenceList ReferenceList -> Map{TrivAsiNat, TrivAsReferenceList} .

	--- ########## VARS ##########
	vars A B C D E F G : iNat .
	vars AcA : Actor .
	vars AcLiA : ActorList .
	vars RefA RefB : Reference .
	vars RefLiA RefLiB RefLiC RefLiD RefLiE RefLiF RefLiG RefLiH : ReferenceList . 
	vars MapNatRefLiA : Map{TrivAsiNat, TrivAsReferenceList} .

	--- ########## EQS ##########
	--- implementations for Actor
	eq newActor(A, RefLiA) = < i: A | sn: 0 | r: RefLiA | dr: mtRef | o: mtRef | ro: mtRef | m: mtRef | tr: mtRef | owr: mtRef | oa: empty > .
	--- implementations for Spawn
	eq spawn(A, RefLiA) = newActor(A, RefLiA) .
	--- implementations for createRef
	eq createRef(A , B :: C -> D , E :: F -> G) = A :: G -> D .
	--- implementation of receive
	eq receive(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, RefA) =
		< i: A | sn: B | r: RefA , RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > .
	--- implementation of release
	eq release(< i: A | sn: B | r: RefA, RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, RefA) = 
		< i: A | sn: B | r: RefLiA | dr: RefA, RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > .
	--- implementation of update info
	eq updateInfo(< i: A | sn: C | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, B) =
		< i: A | sn: s C | r: RefLiA | dr: remList(releasingRefList(B, RefLiB), RefLiB) 
		| o: RefLiC | ro: RefLiD | m: RefLiE | tr: createdRefList(B, RefLiE, RefLiF), RefLiF | owr: sentRefList(B, RefLiE, RefLiG),RefLiG 
		| oa: insert(s C, ((releasingRefList(B, RefLiB) U sentRefList(B, RefLiE, RefLiG)) U createdRefList(B, RefLiE, RefLiF)),MapNatRefLiA) > .

	--- ########## HELPER EQS ##########
	--- implementation of releasingEquiv
	eq releasingEquiv(B, C :: D -> E) = B ~iN E .
	
	--- implementation of releasingRefList
	eq releasingRefList(B, mtRefList) = mtRefList . --- termination
	eq releasingRefList(B, ((A :: C -> B), RefLiA)) = (A :: C -> B), releasingRefList(B, RefLiA). --- ref matches in dr
	eq releasingRefList(B, ((A :: C -> D), RefLiA)) = releasingRefList(B, RefLiA) . --- ref does not match in dr
	
	--- implmentation of createdRefList
	eq createdRefList(B, mtRefList, RefLiB) = mtRefList . --- termination
	--- ref in mem and tr 
	eq createdRefList(B, ((A :: C -> B), RefLiA), (RefLiB, (A :: C -> B), RefLiC)) = createdRefList(B, RefLiA, (RefLiB, RefLiC)) .
	--- ref in mem and not in tr
	--- this is the case where tr is empty
	eq createdRefList(B, ((A :: C -> B), RefLiA), mtRefList) = (A :: C -> B), createdRefList(B, RefLiA, mtRefList) .
	--- NOTE: Due to unique reference IDs, A :: C -> B and A :: D -> B cannot occur
	--- this is the case where tr is not empty
	eq createdRefList(B, ((A :: C -> B), RefLiA), (RefLiB, (D :: E -> F), RefLiC)) = (A :: C -> B), createdRefList(B, RefLiA, (RefLiB, (D :: E -> F), RefLiC)) .
	--- ref is not in mem
	eq createdRefList(B, ((A :: C -> D), RefLiA), RefLiB) = createdRefList(B, RefLiA, RefLiB) .

	--- implementation of sentRefList
	eq sentRefList(B, mtRefList, RefLiB) = mtRefList . --- termination
	--- ref in mem and owr
	eq sentRefList(B, ((A :: B -> C), RefLiA), (RefLiB, (A :: B -> C), RefLiC)) = sentRefList(B, RefLiA, (RefLiB, RefLiC)) .
	--- ref in mem and not in owr
	--- this is the case where owr is empty
	eq sentRefList(B, ((A :: B -> C), RefLiA), mtRefList) = (A :: B -> C), sentRefList(B, RefLiA, mtRefList) .
	--- NOTE: Due to unique reference IDs, A :: C -> B and A :: D -> B cannot occur
	--- this is the case where tr is not empty
	eq sentRefList(B, ((A :: B -> C), RefLiA), (RefLiB, (D :: E -> F), RefLiC)) = (A :: B -> C), sentRefList(B, RefLiA, (RefLiB, (D :: E -> F), RefLiC)) .
	--- ref is not in mem
	eq sentRefList(B, ((A :: C -> D), RefLiA), RefLiB) = sentRefList(B, RefLiA, RefLiB) .
endfm