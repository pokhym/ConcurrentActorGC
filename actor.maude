***(
	TODO:
	constants in PRED should be "true" and "false" for rltool to do auto matching
	rename to BOOL module name as well

	untested ops
	newActor
	spawn
	releaseRecv
)

set include BOOL off .

--- load util.maude
load reference.maude

view TrivAsReferenceList from TRIV to REFERENCE is
	sort Elt to ReferenceListUnion .
endv

view TrivAsiNat from TRIV to INAT is
	sort Elt to iNat .
endv

fmod ACTOR is 
	protecting PRED .
	protecting INAT .
	protecting REFERENCE .
	protecting MAP{TrivAsiNat, TrivAsReferenceList} .
	
	--- ########## SORTS ##########
	sorts Actor NeActorList ActorList .
	
	--- ########## SUBSORTS ##########
	subsorts Actor < NeActorList < ActorList .

	--- ########## OPS ##########
	--- identities
	--- op mtActor : -> Actor [ctor] .
	op mtActorList : -> ActorList [ctor] .

	--- i = id, sn = seqnum, r = refs, dr = deactivated_refs, o = owners, ro = released_owners, 
	--- m = memory, tr = target_releasing, owr = owner_releasing, oa = onack
	op < i: _ | sn: _ | r: _ | dr: _ | o: _ | ro: _ | m: _ | tr: _ | owr: _ | oa: _ > : 
		iNat iNat ReferenceList ReferenceList ReferenceList ReferenceList ReferenceList 
			ReferenceList ReferenceList Map{TrivAsiNat, TrivAsReferenceList} ->  Actor [ctor] .
	--- TODO: Should this check for uniqueness (set) for i?
	op _;_ : ActorList ActorList -> ActorList [ctor assoc id: mtActorList] .
	op _;_ : NeActorList ActorList -> ActorList [ctor ditto] .
	op _;_ : ActorList NeActorList -> ActorList [ctor ditto] .

	--- Methods Declarations an Actor has
	--- Actor Constructor: ActorID1 to be created, ActorID2 of first reference, next unique refID
	--- NOTE: refID :: ActorID1 -> ActorID2
	op newActor(_,_,_) : iNat iNat iNat -> Actor [ctor] .
	--- Spawn: Allows an actor A to spawn a child, this is just a renaming of newActor
	--- NOTE: this only updates A's references, a rule will actually call newActor
	op spawn(_,_,_) : Actor iNat iNat -> ActorList .
	--- createRef: Creates a reference C -> B if given A -> B and A -> C
	op createRef(_,_,_) : iNat Reference Reference -> Reference .
	--- receive: Allows an actor A to recieve a new reference
	op receive(_,_) : Actor Reference -> Actor .
	--- release: Allows an actor to release an input reference, this only edits deactivated_refs
	--- updateInfo will be called alongside release in the relese rule which will also do error checking to see if
	--- the input reference is actually in the Actor.refs
	op release(_,_) : Actor Reference -> Actor .
	--- updateInfo: Called by actor A release an actor B to update local variables
	--- the actual release message will be created and sent via the rule into the soup
	op updateInfo(_,_) : Actor iNat -> Actor .
	--- This calls both release for an input reference list given from a releaseReq message, this also calls update info
	op releaseReferenceList(_,_) : Actor ReferenceList -> Actor .
	--- releaseRecv: Called by an actor B which received a recieve request from A
	--- this will release references in B and send an ack to A
	--- NOTE: the ackRelease message will be generated by a rule
	op releaseRecvReleasing(_,_) : Actor iNat -> Actor .
	op releaseRecvCreated(_,_) : Actor iNat -> Actor .
	op releaseRecv(_,_) : Actor iNat -> Actor .
	--- this operator creates a snapshot for an actor for sn N
	op createSnapshot(_) : iNat -> ReferenceList .
	--- ackRelease: This is sent by actor B to A as an ack, we set map[N] to mtRefList
	op ackRelease(_,_) : Actor iNat -> Actor .

	--- ########## HELPER OPS ##########
	--- releasingEquiv(B, x : A -> B) = tt, releasingEquiv(B, x : A -> C) = ff
	op releasingEquiv(_,_) : iNat Reference -> Pred .
	--- releasingRefList(B, (x : A -> B), (y : C -> B), (z : D -> E)) returns x, y
	--- b: B, deactivatedRefs
	--- op releasingRefList(_,_) : iNat ReferenceList -> ReferenceList .
	op releasingRefList(_,_) : iNat ReferenceList -> ReferenceList .
	--- createdRefList(B, (x : A -> B), (y : C -> B), (z : D -> B), (y : C -> B)) returns z : D -> B
	--- b : B, Memory, TargetReleasing
	op createdRefList(_,_,_) : iNat ReferenceList ReferenceList -> ReferenceList .
	--- sentRefList(B, (x : A -> B), (y : E -> C), (z : B -> D), (y : C -> B)) returns z : B -> D
	op sentRefList(_,_,_) : iNat ReferenceList ReferenceList -> ReferenceList .
	--- getReleasing
	op getReleasing(_) : ReferenceListUnion -> ReferenceList .
	--- getCreated
	op getCreated(_) : ReferenceListUnion -> ReferenceList .
	--- getSent
	op getSent(_) : ReferenceListUnion -> ReferenceList .

	--- ########## VARS ##########
	vars N X A B C D E F G : iNat .
	vars AcA : Actor .
	vars AcLiA AcLiB AcLiC AcLiD : ActorList .
	vars RefA RefB : Reference .
	vars RefLiA RefLiB RefLiC RefLiD RefLiE RefLiF RefLiG RefLiH RefLiI RefLiJ RefLiK RefLiL RefLiM RefLiN : ReferenceList . 
	vars MapNatRefLiA MapNatRefLiB : Map{TrivAsiNat, TrivAsReferenceList} .

	--- ########## EQS ##########
	--- Uniqueness
	--- eq mtActor ; mtActor = mtActor .
	--- eq mtActor ; AcLiA = AcLiA .
	--- eq AcLiA ; mtActor = AcLiA .
	eq (AcLiA ; (< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >) ; AcLiB)
		; (AcLiC ; (< i: A | sn: C | r: RefLiH | dr: RefLiI | o: RefLiJ | ro: RefLiK | m: RefLiL | tr: RefLiM | owr: RefLiN | oa: MapNatRefLiB >) ; AcLiD)
			= AcLiA ; (< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >) ; AcLiB ; AcLiC ; AcLiD .
	--- implementations for Actor
	eq newActor(A, B, X) = < i: A | sn: 0 | r: mtRefList | dr: mtRefList | o: (X :: B -> A) | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > .
	--- implementations for Spawn
	eq spawn(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, B, X) = 
		< i: A | sn: B | r: (X :: A -> B), RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > .
	--- implementations for createRef
	eq createRef(A , B :: C -> D , E :: F -> G) = A :: G -> D .
	--- implementation of receive
	eq receive(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, RefA) =
		< i: A | sn: B | r: RefA , RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > .
	--- implementation of release
	eq release(< i: A | sn: B | r: RefA, RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, RefA) = 
		< i: A | sn: B | r: RefLiA | dr: RefA, RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > .
	--- implementation of update info
	eq updateInfo(< i: A | sn: C | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, B) =
		< i: A | sn: s C | r: RefLiA | dr: remList(releasingRefList(B, RefLiB), RefLiB) 
		| o: RefLiC | ro: RefLiD | m: RefLiE | tr: createdRefList(B, RefLiE, RefLiF), RefLiF | owr: sentRefList(B, RefLiE, RefLiG),RefLiG 
		| oa: insert(s C, (releasingRefList(B, RefLiB) U sentRefList(B, RefLiE, RefLiG) U createdRefList(B, RefLiE, RefLiF)),MapNatRefLiA) > .
	--- implementation of releaseReferenceList
	eq releaseReferenceList(AcA, mtRefList) = AcA .
	eq releaseReferenceList(AcA, ((X :: A -> B), RefLiA)) = releaseReferenceList(updateInfo(release(AcA, (A :: A -> B)), B), RefLiA) .
	--- implementation of releaseRecv
	--- remove released (first for loop)
	ceq releaseRecvReleasing(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefA, RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, N) =
		releaseRecvReleasing(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, N) if (RefA in getReleasing(MapNatRefLiA[N])) = tt .
	eq releaseRecvReleasing(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefA, RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, N) =
		< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefA, RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > [owise] .
	--- remove created (second for loop)
	ceq releaseRecvCreated(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefA, RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, N) =
		releaseRecvCreated(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, N) if (RefA in getCreated(MapNatRefLiA[N])) = tt .
	eq releaseRecvCreated(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefA, RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, N) =
		< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefA, RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > [owise] .
	eq releaseRecv(AcA, N) = releaseRecvCreated(releaseRecvReleasing(AcA, N), N) .

	--- implementation on ackRelease
	eq ackRelease(< i: A | sn: C | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, N) =
		< i: A | sn: C | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: insert(N, mtRefListUnion, MapNatRefLiA) > .


	--- ########## HELPER EQS ##########
	--- implementation of releasingEquiv
	eq releasingEquiv(B, C :: D -> E) = B ~iN E .
	
	--- implementation of releasingRefList
	eq releasingRefList(B, mtRefList) = mtRefList . --- termination
	eq releasingRefList(B, ((A :: C -> B), RefLiA)) = (A :: C -> B), releasingRefList(B, RefLiA). --- ref matches in dr
	eq releasingRefList(B, ((A :: C -> D), RefLiA)) = releasingRefList(B, RefLiA) . --- ref does not match in dr
	
	--- implmentation of createdRefList
	eq createdRefList(B, mtRefList, RefLiB) = mtRefList . --- termination
	--- ref in mem and tr 
	eq createdRefList(B, ((A :: C -> B), RefLiA), (RefLiB, (A :: C -> B), RefLiC)) = createdRefList(B, RefLiA, (RefLiB, RefLiC)) .
	--- ref in mem and not in tr
	--- this is the case where tr is empty
	eq createdRefList(B, ((A :: C -> B), RefLiA), mtRefList) = (A :: C -> B), createdRefList(B, RefLiA, mtRefList) .
	--- NOTE: Due to unique reference IDs, A :: C -> B and A :: D -> B cannot occur
	--- this is the case where tr is not empty
	eq createdRefList(B, ((A :: C -> B), RefLiA), (RefLiB, (D :: E -> F), RefLiC)) = (A :: C -> B), createdRefList(B, RefLiA, (RefLiB, (D :: E -> F), RefLiC)) .
	--- ref is not in mem
	eq createdRefList(B, ((A :: C -> D), RefLiA), RefLiB) = createdRefList(B, RefLiA, RefLiB) .

	--- implementation of sentRefList
	eq sentRefList(B, mtRefList, RefLiB) = mtRefList . --- termination
	--- ref in mem and owr
	eq sentRefList(B, ((A :: B -> C), RefLiA), (RefLiB, (A :: B -> C), RefLiC)) = sentRefList(B, RefLiA, (RefLiB, RefLiC)) .
	--- ref in mem and not in owr
	--- this is the case where owr is empty
	eq sentRefList(B, ((A :: B -> C), RefLiA), mtRefList) = (A :: B -> C), sentRefList(B, RefLiA, mtRefList) .
	--- NOTE: Due to unique reference IDs, A :: C -> B and A :: D -> B cannot occur
	--- this is the case where tr is not empty
	eq sentRefList(B, ((A :: B -> C), RefLiA), (RefLiB, (D :: E -> F), RefLiC)) = (A :: B -> C), sentRefList(B, RefLiA, (RefLiB, (D :: E -> F), RefLiC)) .
	--- ref is not in mem
	eq sentRefList(B, ((A :: C -> D), RefLiA), RefLiB) = sentRefList(B, RefLiA, RefLiB) .
	
	--- getReleasing implementation
	eq getReleasing(RefLiA U RefLiB U RefLiC) = RefLiA .
	--- getCreated
	eq getCreated(RefLiA U RefLiB U RefLiC) = RefLiB .
	--- getSend
	eq getSent(RefLiA U RefLiB U RefLiC) = RefLiC .
endfm

--- --- unchanged
--- red release(< i: 0 | sn: 0 | r: (s 0 :: s 0 -> s 0) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, mtRefList) .
--- red release(< i: 0 | sn: 0 | r: (s 0 :: s 0 -> s 0) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- red release(< i: 0 | sn: 0 | r: ((s 0 :: s 0 -> s 0), (s s 0 :: s s 0 -> s s 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- --- add 0 :: 0 -> 0 to dr
--- red release(< i: 0 | sn: 0 | r: (0 :: 0 -> 0) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- red release(< i: 0 | sn: 0 | r: ((s 0 :: s 0 -> s 0), (0 :: 0 -> 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- red release(< i: 0 | sn: 0 | r: ((0 :: 0 -> 0), (s s 0 :: s s 0 -> s s 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .

--- --- unchanced
--- red releaseReferenceList(< i: 0 | sn: 0 | r: (s 0 :: s 0 -> s 0) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, mtRefList) .
--- red releaseReferenceList(< i: 0 | sn: 0 | r: (s 0 :: s 0 -> s 0) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- red releaseReferenceList(< i: 0 | sn: 0 | r: ((s 0 :: s 0 -> s 0), (s s 0 :: s s 0 -> s s 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- --- add 0 :: 0 -> 0 to dr
--- red releaseReferenceList(< i: 0 | sn: 0 | r: (0 :: 0 -> 0) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- red releaseReferenceList(< i: 0 | sn: 0 | r: ((s 0 :: s 0 -> s 0), (0 :: 0 -> 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- red releaseReferenceList(< i: 0 | sn: 0 | r: ((0 :: 0 -> 0), (s s 0 :: s s 0 -> s s 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, (0 :: 0 -> 0) ) .
--- --- only adds 0 :: 0 -> 0
--- red releaseReferenceList(< i: 0 | sn: 0 | r: (0 :: 0 -> 0) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, ((0 :: 0 -> 0), (s 0 :: s 0 -> s 0)) ) .
--- red releaseReferenceList(< i: 0 | sn: 0 | r: ((0 :: 0 -> 0), (s s 0 :: s s 0 -> s s 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, ((0 :: 0 -> 0), (s 0 :: s 0 -> s 0)) ) .
--- --- add 0 :: 0 -> 0 and s 0 :: s 0 -> s 0 to dr
--- red releaseReferenceList(< i: 0 | sn: 0 | r: ((s 0 :: s 0 -> s 0), (0 :: 0 -> 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, ((0 :: 0 -> 0), (s 0 :: s 0 -> s 0)) ) .


--- --- removes nothing
--- red ackRelease(releaseReferenceList(< i: 0 | sn: 0 | r: ((s 0 :: s 0 -> s 0), (0 :: 0 -> 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, ((0 :: 0 -> 0), (s 0 :: s 0 -> s 0)) ), 0) .
--- --- sets s 0 in map to mtRefList
--- red ackRelease(releaseReferenceList(< i: 0 | sn: 0 | r: ((s 0 :: s 0 -> s 0), (0 :: 0 -> 0)) | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty >, ((0 :: 0 -> 0), (s 0 :: s 0 -> s 0)) ), s 0) .

--- --- returns only releasing
--- red getReleasing(insert(0, ((0 :: 0 -> s 0),s 0 :: s 0 -> s 0) U s s s s s 0 :: s 0 -> s s s 0 U (s s s 0 :: s s s 0 -> s 0),s s s s 0 :: s s s s 0 -> s 0, empty)[0]) .
--- --- returns only created
--- red getCreated(insert(0, ((0 :: 0 -> s 0),s 0 :: s 0 -> s 0) U s s s s s 0 :: s 0 -> s s s 0 U (s s s 0 :: s s s 0 -> s 0),s s s s 0 :: s s s s 0 -> s 0, empty)[0]) .
--- --- returns only sent
--- red getSent(insert(0, ((0 :: 0 -> s 0),s 0 :: s 0 -> s 0) U s s s s s 0 :: s 0 -> s s s 0 U (s s s 0 :: s s s 0 -> s 0),s s s s 0 :: s s s s 0 -> s 0, empty)[0]) .

--- red releaseRecvReleasing(< i: 0 | sn: 0 | r: (s 0 :: s 0 -> s 0) | dr: mtRefList | o: (0 :: 0 -> 0), (s 0 :: s 0 -> s 0) | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: insert(0, ((0 :: 0 -> 0) , (s s 0 :: s s 0 -> s s 0) U mtRefList U mtRefList), empty) >, 0) .


--- red mtActorList .
--- red mtActorList ; mtActorList .
--- red mtActorList ; A:Actor .
--- red A:Actor ; mtActorList .
--- red < i: 0 | sn: 0 | r: mtRefList | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > ; mtActorList .
--- red mtActorList ; < i: 0 | sn: 0 | r: mtRefList | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > .
--- red < i: 0 | sn: 0 | r: mtRefList | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > ; < i: 0 | sn: s 0 | r: mtRefList | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > .
--- red < i: 0 | sn: s 0 | r: mtRefList | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > ; < i: 0 | sn: 0 | r: mtRefList | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > .
--- red < i: 0 | sn: 0 | r: mtRefList | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > ; < i: s 0 | sn: s 0 | r: mtRefList | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > ; < i: s 0 | sn: 0 | r: RefLiA | dr: mtRefList | o: mtRefList | ro: mtRefList | m: mtRefList | tr: mtRefList | owr: mtRefList | oa: empty > .

--- red insert(0, mtRefList, insert(0, ((0 :: 0 -> 0),s 0 :: s 0 -> s 0), empty)) .