set include BOOL off .

fmod PRED is
	--- ########## SORTS ##########
	sorts Pred .
	--- ########## SUBSORTS ##########
	--- ########## OPS ##########
	op tt : -> Pred [ctor] .
	op ff : -> Pred [ctor] .
endfm

fmod REFERENCE is protecting NAT .
	--- ########## SORTS ##########
	sorts Reference ReferenceList .
	--- ########## SUBSORTS ##########
	subsort Reference < ReferenceList .
	--- ########## OPS ##########
	op mtRef : -> Reference [ctor] .
	op mtRefList : -> ReferenceList [ctor] .
	--- References
	op _::_->_ : Nat Nat Nat -> Reference [ctor] .
	--- op __ : Reference Reference -> ReferenceList [ctor] .
	--- TODO: Should this check for uniqueness (set) for each reference?
	op _,_ : ReferenceList ReferenceList -> ReferenceList [ctor assoc id: mtRefList] .
endfm

view TrivAsReferenceList from TRIV to REFERENCE is
	sort Elt to ReferenceList .
endv

fmod ACTOR is protecting NAT .
	protecting QID-LIST .
	protecting REFERENCE .
	protecting PRED .
	protecting MAP{Nat, TrivAsReferenceList} .
	--- ########## SORTS ##########
	--- sorts List QidList .
	sorts Actor ActorList .
	
	--- ########## SUBSORTS ##########
	--- We want to be able to have a list of references
	--- subsort Reference Msg Actor < Qid < ReferenceList MsgList ActorList < QidList . 
	subsort Actor < ActorList .

	--- ########## OPS ##########
	--- identities
	op mtActor : -> Actor [ctor] .
	op mtActorList : -> ActorList [ctor] .

	--- i = id, sn = seqnum, r = refs, dr = deactivated_refs, o = owners, ro = released_owners, 
	--- m = memory, tr = target_releasing, owr = owner_releasing, oa = onack
	op < i: _ | sn: _ | r: _ | dr: _ | o: _ | ro: _ | m: _ | tr: _ | owr: _ | oa: _ > : 
		Nat Nat ReferenceList ReferenceList ReferenceList ReferenceList ReferenceList 
			ReferenceList ReferenceList Map{Nat, TrivAsReferenceList} ->  Actor [ctor] .
	--- TODO: Should this check for uniqueness (set) for i?
	op _,_ : ActorList ActorList -> ActorList [ctor assoc id: mtActorList] .

	--- Methods Declarations an Actor has
	--- Actor Constructor: ActorID1 to be created, ActorID2 of first reference, next unique refID
	--- NOTE: refID :: ActorID1 -> ActorID2
	op newActor(_,_) : Nat ReferenceList -> Actor [ctor] .
	--- Spawn: Allows an actor A to spawn a child, this is just a renaming of newActor
	--- to spawn multiple actors refer to the rules in G
	op spawn(_,_) : Nat ReferenceList -> ActorList .
	--- createRef: Creates a reference C -> B if given A -> B and A -> C
	op createRef(_,_,_) : Nat Reference Reference -> Reference .
	--- receive: Allows an actor A to recieve a new reference
	op receive(_,_) : Actor Reference -> Actor .
	--- release: Allows an actor to release an input reference, this only edits deactivated_refs
	--- updateInfo will be called alongside release in the relese rule which will also do error checking to see if
	--- the input reference is actually in the Actor.refs
	op release(_,_) : Actor Reference -> Actor .
	--- updateInfo: Called by actor A release an actor B to update local variables
	--- the actual release message will be created and sent via the rule into the soup
	op updateInfo(_,_) : Actor Nat -> Actor .
	--- releaseRecv: Called by an actor B which received a recieve request from A
	--- this will release references in B and send an ack to A
	op releaseRecv(_,_,_,_) : Nat Nat ReferenceList ReferenceList -> Actor .
	--- ackRelease: This is sent by actor B to A as an ack
	op ackRelease(_) : Nat -> Actor .

	--- ########## HELPER OPS ##########
	--- realeasingEquiv(B, x : A -> B) = tt, realeasingEquiv(B, x : A -> C) = ff
	op realeasingEquiv(_,_) : Nat Reference -> Pred .
	--- releasingRefList(B, (x : A -> B), (y : C -> B), (z : D -> E)) returns x, y
	--- b: B, deactivatedRefs
	op releasingRefList(_,_) : Nat ReferenceList -> ReferenceList .
	--- removeRefsFromRefList
	op removeRefsFromRefList(_,_) : ReferenceList ReferenceList -> ReferenceList .
	--- createdRefList(B, (x : A -> B), (y : C -> B), (z : D -> B), (y : C -> B)) returns z : D -> B
	--- b : B, Memory, TargetReleasing
	op createdRefList(_,_,_) : Nat ReferenceList ReferenceList -> ReferenceList .
	--- A inRefList B:  checks the membership of A in B
	op _inRefList_ : Reference ReferenceList -> Pred .
	--- A URefList B : Set Union with 2 reference lists
	op _URefList_ : ReferenceList ReferenceList -> ReferenceList .
	--- sentRefList(B, (x : A -> B), (y : E -> C), (z : B -> D), (y : C -> B)) returns z : B -> D
	op sentRefList(_,_,_) : Nat ReferenceList ReferenceList -> ReferenceList .
	--- sentEquiv(B, x : A -> B) = ff, sentEquiv(B, x : B -> C) = tt
	op sentEquiv(_,_) : Nat Reference -> Pred .
	--- genOnAckMap()
	op genOnAckMap(_,_,_) : ReferenceList ReferenceList ReferenceList -> Map{Nat, TrivAsReferenceList} .

	--- ########## VARS ##########
	vars A B C D E F G : Nat .
	vars AcA : Actor .
	vars AcLiA : ActorList .
	vars RefA RefB : Reference .
	vars RefLiA RefLiB RefLiC RefLiD RefLiE RefLiF RefLiG RefLiH : ReferenceList . 
	vars MapNatRefLiA : Map{Nat, TrivAsReferenceList} .

	--- ########## EQS ##########
	--- implementations for Actor
	eq newActor(A, RefLiA) = < i: A | sn: 0 | r: RefLiA | dr: mtRef | o: mtRef | ro: mtRef | m: mtRef | tr: mtRef | owr: mtRef | oa: empty > .
	--- implementations for Spawn
	eq spawn(A, RefLiA) = newActor(A, RefLiA) .
	--- implementations for createRef
	eq createRef(A , B :: C -> D , E :: F -> G) = A :: G -> D .
	--- implementation of receive
	eq receive(< i: A | sn: B | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, RefA) =
		< i: A | sn: B | r: RefA , RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > .
	--- implementation of release
	eq release(< i: A | sn: B | r: RefA, RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, RefA) = 
		< i: A | sn: B | r: RefLiA | dr: RefA, RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA > .
	--- implementation of update info
	eq updateInfo(< i: A | sn: C | r: RefLiA | dr: RefLiB | o: RefLiC | ro: RefLiD | m: RefLiE | tr: RefLiF | owr: RefLiG | oa: MapNatRefLiA >, B) =
		< i: A | sn: C + 1 | r: RefLiA | dr: releasingRefList(B, RefLiB) | o: RefLiC | ro: RefLiD | 
			m: RefLiE | tr: createdRefList(B, RefLiE, RefLiF), RefLiF | owr: sentRefList(B, RefLiE, RefLiG), RefLiG | 
			oa: insert(C + 1, (releasingRefList(B, RefLiB),createdRefList(B, RefLiE, RefLiF),sentRefList(B, RefLiE, RefLiG)),empty), MapNatRefLiA > .

	--- ########## HELPER EQS ##########
	--- implementation of realeasingEquiv
	eq realeasingEquiv(B, C :: D -> E) =
		if E == B then
			tt
		else
			ff
		fi .
	--- implementation of releasingRefList
	eq releasingRefList(B, mtRefList) = mtRefList .
	eq releasingRefList(B, (RefA, RefLiA)) =
		if (RefA) == mtRef then
			mtRefList
		else if realeasingEquiv(B, RefA) == ff then
			RefA, releasingRefList(B, RefLiA)
		else
			releasingRefList(B, RefLiA)
		fi
		fi .
	--- implmentation of createdRefList
	eq createdRefList(B, mtRefList, RefLiB) = mtRefList .
	eq createdRefList(B, (RefA, RefLiA), RefLiB) =
		if (RefA) == mtRef then
			mtRefList
		else if (RefA inRefList RefLiB == ff) and (realeasingEquiv(B, RefA) == tt) then
			RefA, createdRefList(B, RefLiA, RefLiB)
		else
			createdRefList(B, RefLiA, RefLiB)
		fi
		fi .
	--- implmentation of inRefList
	eq RefA inRefList mtRefList = ff .
	eq RefA inRefList (RefB, RefLiA) = 
		if RefA == RefB then
			tt
		else
			RefA inRefList RefLiA
		fi .
	--- implementation of sentRefList
	eq sentRefList(B, mtRefList, RefLiB) = mtRefList .
	eq sentRefList(B, (RefA, RefLiA), RefLiB) = 
		if (RefA) == mtRef then
			mtRefList
		else if (RefA inRefList RefLiB == ff) and (sentEquiv(B, RefA) == tt) then
			RefA, sentRefList(B, RefLiA, RefLiB)
		else
			sentRefList(B, RefLiA, RefLiB)
		fi
		fi .
	--- implementation of sentEquiv
	eq sentEquiv(B, C :: D -> E) =
		if B == D then
			tt
		else
			ff
		fi .
	--- implementation of genOnAckMap
endfm

fmod MSG is protecting NAT .
	protecting ACTOR .
	--- ########## SORTS ##########
	sorts Msg MsgList MsgType .
	--- ########## SUBSORTS ##########
	subsort Msg < MsgList .
	--- ########## OPS ##########
	op mtMsg : -> Msg [ctor] .
	op mtMsgList : -> MsgList [ctor] .
	--- Message Types
	op App : -> MsgType .
	op ReleaseReq : -> MsgType .
	op AckRelease : -> MsgType .
	--- Messages
	--- The three types are App, Req_Release, and Ack_Release. 
	--- I guess there should be another kind of message for asking an actor to take a snapshot?
	--- An App message can do any combination of the following things all at once
	--- - Add all references in the message to the target actorâ€™s state; AND
	--- - Create new App messages, each of which may contain a set of new references; AND
	--- - Spawn new actors; AND
	--- - Create new Req_Release messages.
	--- TODO: This means that we need newActor to handle cases where ActorList is MT
	op @_::_::_::_@ : MsgType ActorList ReferenceList MsgList -> Msg [ctor] .
	op _,_ : MsgList MsgList -> MsgList [ctor assoc id: mtMsgList] .

	--- ########## VARS ##########
	vars MsgA : Msg .
	vars MsgTA : MsgType .
	vars MsgLiA : MsgList .
endfm


mod G is protecting ACTOR . protecting LIST{Nat} . protecting COUNTER .
	--- ########## SORTS ##########
	sorts Configuration NatConfiguration .

	--- ########## SUBSORTS ##########
	subsort Actor < ActorList < QidList .

	--- ########## OPS ##########
	op _$_ : Actor Actor -> ActorList [ctor] .

	--- Top Level G functions
	--- TODO: How do we address getting more than one actor
	op newActorList(_) : List{Nat} -> ActorList [ctor] .
	--- Configuration is a set of actors together
	--- TODO: Does this need to have 2 actorlists? or is it because
	--- We can concatenate actorlists via QID-LIST do we still need to wory about this?
	op { _ } : ActorList -> Configuration [ctor] .

	--- NatConfiguration also gives us global variables for actor ID and reference ID
	--- this allows us to have a unique name for every actor and reference
	--- NextActorID NextReferenceID Configuration -> NatConfiguration
	op ___ : Nat Nat Configuration -> NatConfiguration [ctor] .

	--- Methods for NatConfiguration ########## 
	op getNextActorId(_) : NatConfiguration -> Nat .
	op getNextRefId(_) : NatConfiguration -> Nat .

	--- ########## VARIABLES ##########
	vars N : Nat .


	--- ########## EQ ##########
	--- implementations for NatConfiguration
	--- eq getNextActorId(N M Conf) = N + 1 .
	--- eq getNextRefId(N,M ^ Conf) = M + 1 .

	--- ########## RULES ########## 
	--- rl [newActor] :  ActID || { Conf } => N + 1 || { newActor(N + 1, M) Conf } .

	--- parse App msg rule
	--- pull a message from the soup, if the type is app, and the msg's target is an actor
	--- then we need to spawn an actorlist.  to handle multiple actors we have spawnActorList in G
	--- spawnActorList(Owner:Actor, Curr:Nat, Final:Nat, RefList)
	--- this will spawn Final-Curr actors with RefList references and add them to the soup
	--- spawnActorList(Owner, Curr, Final, RefList) =
	--- if Curr != Final then
	--- 	spawnActor(Owner,Curr,RefList) spawnActorList(Owner, Curr + 1, Final, RefList)
	--- fi .
	--- however we must also remember to edit Owner from the pool to add a New ReferenceList where all
	--- entries are N :: Owner -> Ref (in RefList)
	--- these will use the two natural number counters in a NatConfiguration

	--- parse ReleaseRecv Msg

	--- parse AckRelease Msg

	--- createRef rule
	--- This will call createRef for an actor which will edit its own "owners" list of things to send
	--- this will not generate a message

	--- release rule
	--- this will not only call the release op but also the update info as long as the reference we want to release
	--- exists in the actor we are trying to check

	op inc : -> Nat .
	rl [testcounter] : inc => counter .
endm