load util.maude

fmod REFERENCE is protecting INAT .
	--- ########## SORTS ##########
	sorts Reference NeReferenceList ReferenceList .
	--- ########## SUBSORTS ##########
	subsorts Reference < NeReferenceList < ReferenceList .
	--- ########## OPS ##########
	--- op mtRef : -> Reference [ctor] .
	op mtRefList : -> ReferenceList [ctor] .
	--- References
	--- x : A -> B, where x is a reference ID and A,B are actor IDs
	op _::_->_ : iNat iNat iNat -> Reference [ctor] .
	--- op __ : Reference Reference -> ReferenceList [ctor] .
	--- TODO: Should this check for uniqueness (set) for each reference?
	op _,_ : ReferenceList ReferenceList -> ReferenceList [ctor comm assoc id: mtRefList] .
	op _,_ : NeReferenceList ReferenceList -> NeReferenceList [ctor ditto] .
	op _,_ : ReferenceList NeReferenceList -> NeReferenceList [ctor ditto] .
	--- This removes the references in the first reference list from the second reference list
	op remList(_,_) : ReferenceList ReferenceList -> ReferenceList .
	--- Performs set union on reference lists based upon their membership
	op _U_ : ReferenceList ReferenceList -> ReferenceList .
	--- This returns the length of a reference list
	op lenRL(_) : ReferenceList -> iNat .

	--- ########## VARS ##########
	vars x A B C D : iNat .
	vars RefA RefB : Reference .
	vars RefLiA RefLiB RefLiC RefLiD RefLiE RefLiF RefLiG RefLiH : ReferenceList . 

	--- ########## EQS ##########
	--- Uniqueness equation
	--- NOTE: THIS CHECKS A REFERENCE AS A WHOLE AND NOT JUST THE REFERENCE NUMBER
	--- eq (RefLiA, RefA, RefLiB), (RefLiC, RefA, RefLiD) = RefLiA, RefA, RefLiB, RefLiC, RefLiD .
	--- NOTE: THIS CHECKS A REFERENCE NUMBER SPECIFICALLY
	--- eq mtRef, mtRef = mtRef .
	--- eq mtRef, RefLiA = RefLiA .
	eq (RefLiA, (x :: A -> B), RefLiB), (RefLiC, (x :: C -> D), RefLiD) = RefLiA, (x :: A -> B), RefLiB, RefLiC, RefLiD .
	
	eq remList(mtRefList, RefLiA) = RefLiA . --- termination
	eq remList((RefA, RefLiA), (RefLiB, RefA, RefLiC)) = remList(RefLiA, (RefLiB, RefLiC)) . --- remove case
	eq remList((RefA, RefLiA), (RefLiB, RefB, RefLiC)) = RefB, remList(RefLiA, (RefLiB, RefLiC)) . --- doesn't exist recreate

	eq mtRefList U mtRefList = mtRefList .
	eq RefLiA U mtRefList = RefLiA .
	eq mtRefList U RefLiA = RefLiA .
	eq (RefA, RefLiA) U (RefA, RefLiB) = RefA, (RefLiA U RefLiB) .
	eq (RefA, RefLiA) U (RefB, RefLiB) = RefA, RefB, (RefLiA U RefLiB) .

	eq lenRL(mtRefList) = 0 .
	eq lenRL(RefA, RefLiA) = s lenRL(RefLiA) .
endfm

--- red mtRefList, (0 :: 0 -> 0) .
--- red (0 :: 0 -> 0), mtRefList .
--- red 0 :: 0 -> 0 .
--- red (0 :: 0 -> 0), (0 :: 0 -> 0) .
--- red (0 :: 0 -> 0), (s 0 :: 0 -> 0), (s 0 :: 0 -> 0), (0 :: 0 -> 0)  .
--- red (0 :: 0 -> s 0), (s 0 :: 0 -> 0), (s s 0 :: 0 -> 0), (0 :: 0 -> 0), (s s s 0 :: 0 -> 0), (s 0 :: 0 -> 0), (0 :: 0 -> 0), (s s s s 0 :: 0 -> 0), (0 :: 0 -> 0) .


--- return mt list
--- red remList(mtRefList, mtRefList) .
--- red remList(mtRefList, 0 :: s 0 -> s s 0) .
--- return non-empty list
--- red remList((0 :: s 0 -> s s 0), ((0 :: s 0 -> s s 0), (s s s 0 :: s s s s 0 -> s s s s s 0), (s s s s s s 0 :: s s s s s s s 0 -> s s s s s s s s 0))) .
--- red remList(((s s s s s s 0 :: s s s s s s s 0 -> s s s s s s s s 0), (0 :: s 0 -> s s 0)), ((0 :: s 0 -> s s 0), (s s s 0 :: s s s s 0 -> s s s s s 0), (s s s s s s 0 :: s s s s s s s 0 -> s s s s s s s s 0))) .

--- --- union 2 mts should still be mt
--- red mtRefList U mtRefList .
--- --- union of mt and non empty should be non-empty
--- red mtRefList U 0 :: s 0 -> s s 0 .
--- red 0 :: s 0 -> s s 0  U mtRefList .
--- --- below case covers duplicates 
--- red ((0 :: 0 -> 0),(s 0 :: 0 -> 0)) U ((s s 0 :: 0 -> 0),(s s s 0 :: 0 -> 0)) .
--- red ((0 :: 0 -> 0),mtRefList,(s 0 :: 0 -> 0)) U ((s 0 :: 0 -> 0),(s s s 0 :: 0 -> 0)) .

--- red lenRL(mtRefList) .
--- red lenRL(0 :: 0 -> 0) .
--- red lenRL(mtRefList, (0 :: 0 -> 0)) .
--- red lenRL((0 :: 0 -> 0), mtRefList, (s 0 :: s 0 -> s 0)) .
